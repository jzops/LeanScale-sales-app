/**
 * SowBuilder - Main SOW builder orchestrating diagnostic item selection + section management
 *
 * Two-panel layout:
 *   Left:  DiagnosticItemPicker (select items to include)
 *   Right: SectionEditor list (organize items into named bundles)
 *
 * Props:
 *   sow              - The SOW object (from API)
 *   sections         - Array of SOW sections (from API)
 *   diagnosticResult - The diagnostic result object with processes array
 *   onSave()         - Callback after saving
 */

import { useState, useMemo, useRef, useCallback } from 'react';
import DiagnosticItemPicker from './DiagnosticItemPicker';
import SectionEditor from './SectionEditor';
import SectionConfigurator from './SectionConfigurator';
import InvestmentConfigurator from './InvestmentConfigurator';
import TimelineConfigurator from './TimelineConfigurator';
import CatalogPicker from './CatalogPicker';
import ExecutiveSummaryEditor from './ExecutiveSummaryEditor';
import AssumptionsEditor from './AssumptionsEditor';

export default function SowBuilder({
  sow,
  sections: initialSections = [],
  diagnosticResult,
  onSave,
}) {
  const [sections, setSections] = useState(initialSections);
  const [executiveSummary, setExecutiveSummary] = useState(
    sow?.content?.executive_summary || ''
  );
  const [regenerating, setRegenerating] = useState(false);
  const [groupBy, setGroupBy] = useState('function');
  const [selectedItems, setSelectedItems] = useState(() => {
    // If sections already have assigned items, use those
    const existingItems = new Set();
    initialSections.forEach(s => {
      (s.diagnostic_items || []).forEach(name => existingItems.add(name));
    });
    if (existingItems.size > 0) {
      return Array.from(existingItems);
    }
    // New SOW with no assigned items: auto-select warning/unable items
    const processes = diagnosticResult?.processes || [];
    return processes
      .filter(p => p.status === 'warning' || p.status === 'unable')
      .map(p => p.name);
  });
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);
  const [activeSection, setActiveSection] = useState(null); // section ID being assigned items to
  const [showCatalog, setShowCatalog] = useState(false);
  const [investmentConfig, setInvestmentConfig] = useState(
    sow?.content?.investment_config || {
      defaultRate: 250,
      globalDiscount: 0,
      paymentTerms: 'Net 30',
      currency: 'USD',
      taxRate: 0,
      pricingMode: 'Fixed Price',
    }
  );
  const [velocity, setVelocity] = useState(sow?.content?.velocity || 40);
  const dragItem = useRef(null);
  const dragOverItem = useRef(null);

  const processes = diagnosticResult?.processes || [];

  // Build a map of process name â†’ process data for quick lookup
  const processMap = useMemo(() => {
    const map = {};
    processes.forEach(p => { map[p.name] = p; });
    return map;
  }, [processes]);

  // Detect if SOW was auto-generated (has sections with diagnostic_items)
  const isAutoGenerated = useMemo(() => {
    return initialSections.some(s => s.diagnostic_items && s.diagnostic_items.length > 0);
  }, [initialSections]);

  // Save executive summary to API
  const saveExecutiveSummary = useCallback(async () => {
    try {
      await fetch(`/api/sow/${sow.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: { ...sow.content, executive_summary: executiveSummary },
        }),
      });
    } catch (err) {
      setError('Failed to save executive summary.');
    }
  }, [sow.id, sow.content, executiveSummary]);

  // Save investment config to SOW content
  const saveInvestmentConfig = useCallback(async (newConfig) => {
    setInvestmentConfig(newConfig);
    try {
      await fetch(`/api/sow/${sow.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contentPartial: { investment_config: newConfig },
        }),
      });
    } catch (err) {
      setError('Failed to save investment configuration.');
    }
  }, [sow.id]);

  // Apply default rate to all sections
  async function applyRateToAll(rate) {
    const updates = sections.map(s =>
      fetch(`/api/sow/${sow.id}/sections/${s.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ rate }),
      }).then(r => r.json())
    );
    try {
      const results = await Promise.all(updates);
      setSections(prev => prev.map(s => ({ ...s, rate })));
    } catch (err) {
      setError('Failed to apply rate to all sections.');
    }
  }

  // Save velocity to SOW content
  async function handleVelocityChange(v) {
    setVelocity(v);
    try {
      await fetch(`/api/sow/${sow.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ contentPartial: { velocity: v } }),
      });
    } catch (err) { /* silent */ }
  }

  // Regenerate sections from diagnostic
  async function handleRegenerate() {
    if (!confirm('This will replace auto-generated sections. Manually added sections will be preserved. Continue?')) {
      return;
    }
    setRegenerating(true);
    try {
      const diagnosticResultId = sow.diagnostic_result_ids?.[0];
      if (!diagnosticResultId) {
        setError('No diagnostic result linked to this SOW.');
        return;
      }
      const res = await fetch('/api/sow/auto-generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          diagnosticResultId,
          sowId: sow.id,
          groupBy,
          preserveManual: true,
          customerId: sow.customer_id,
          customerName: sow.content?.client_info?.company,
        }),
      });
      const json = await res.json();
      if (json.success) {
        setSections(json.data.sections || []);
        if (json.data.content?.executive_summary) {
          setExecutiveSummary(json.data.content.executive_summary);
        }
      } else {
        setError(json.error || 'Failed to regenerate sections.');
      }
    } catch (err) {
      setError('Failed to regenerate sections. Please try again.');
    } finally {
      setRegenerating(false);
    }
  }

  async function handleGroupByChange(e) {
    setGroupBy(e.target.value);
    // Auto-regenerate with new grouping
    if (isAutoGenerated) {
      const prev = groupBy;
      // Small delay to let state update, then trigger regenerate
      setTimeout(() => handleRegenerate(), 0);
    }
  }

  // Build a map of which items are assigned to which sections
  const assignedItems = useMemo(() => {
    const map = {};
    sections.forEach(s => {
      (s.diagnostic_items || []).forEach(name => {
        map[name] = s.title || 'Untitled Section';
      });
    });
    return map;
  }, [sections]);

  // --- Section CRUD ---

  async function addSection() {
    try {
      const res = await fetch(`/api/sow/${sow.id}/sections`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: `Section ${sections.length + 1}`,
          sortOrder: sections.length,
        }),
      });
      const json = await res.json();
      if (json.success) {
        setSections(prev => [...prev, json.data]);
        setActiveSection(json.data.id);
      }
    } catch (err) {
      setError('Failed to add section. Please try again.');
    }
  }

  async function addSectionFromCatalog(service) {
    setShowCatalog(false);
    try {
      // Use the average of hours_low and hours_high, or hours_low if only one exists
      const hours = service.hours_low && service.hours_high
        ? Math.round((service.hours_low + service.hours_high) / 2)
        : service.hours_low || null;

      const res = await fetch(`/api/sow/${sow.id}/sections`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: service.name,
          description: service.description || '',
          hours: hours,
          rate: service.default_rate ? parseFloat(service.default_rate) : null,
          deliverables: (service.key_steps || []).map(step =>
            typeof step === 'string' ? step : step.name || step.title || String(step)
          ),
          sortOrder: sections.length,
          service_catalog_id: service.id,
        }),
      });
      const json = await res.json();
      if (json.success) {
        setSections(prev => [...prev, json.data]);
        setActiveSection(json.data.id);
      }
    } catch (err) {
      setError('Failed to add section from catalog. Please try again.');
    }
  }

  async function updateSection(sectionId, updates) {
    try {
      const res = await fetch(`/api/sow/${sow.id}/sections/${sectionId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      });
      const json = await res.json();
      if (json.success) {
        setSections(prev => prev.map(s => s.id === sectionId ? json.data : s));
      }
    } catch (err) {
      setError('Failed to update section. Please try again.');
    }
  }

  async function deleteSection(sectionId) {
    try {
      const res = await fetch(`/api/sow/${sow.id}/sections/${sectionId}`, {
        method: 'DELETE',
      });
      const json = await res.json();
      if (json.success) {
        setSections(prev => prev.filter(s => s.id !== sectionId));
      }
    } catch (err) {
      setError('Failed to delete section. Please try again.');
    }
  }

  // --- Assign selected items to active section ---

  function assignItemsToSection(sectionId) {
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    // Get currently unassigned selected items
    const unassigned = selectedItems.filter(name => !assignedItems[name]);
    if (unassigned.length === 0) return;

    const updatedDiagnosticItems = [...(section.diagnostic_items || []), ...unassigned];
    updateSection(sectionId, { diagnosticItems: updatedDiagnosticItems });
  }

  function removeItemFromSection(sectionId, itemName) {
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    const updatedDiagnosticItems = (section.diagnostic_items || []).filter(n => n !== itemName);
    updateSection(sectionId, { diagnosticItems: updatedDiagnosticItems });
  }

  // --- Drag and drop reordering ---

  function handleDragStart(index) {
    dragItem.current = index;
  }

  function handleDragEnter(index) {
    dragOverItem.current = index;
  }

  async function handleDragEnd() {
    if (dragItem.current === null || dragOverItem.current === null) return;
    if (dragItem.current === dragOverItem.current) {
      dragItem.current = null;
      dragOverItem.current = null;
      return;
    }

    const reordered = [...sections];
    const [dragged] = reordered.splice(dragItem.current, 1);
    reordered.splice(dragOverItem.current, 0, dragged);

    setSections(reordered);
    dragItem.current = null;
    dragOverItem.current = null;

    // Persist new order to API
    const ordering = reordered.map((s, i) => ({ id: s.id, sortOrder: i }));
    try {
      await fetch(`/api/sow/${sow.id}/sections`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ordering }),
      });
    } catch (err) {
      setError('Failed to save section order. Please try again.');
    }
  }

  // --- Save all & recalculate totals ---

  async function handleSaveAll() {
    setSaving(true);
    try {
      // Calculate totals from all sections
      let totalHours = 0;
      let totalInvestment = 0;
      let minDate = null;
      let maxDate = null;

      sections.forEach(s => {
        const h = parseFloat(s.hours) || 0;
        const r = parseFloat(s.rate) || 0;
        totalHours += h;
        totalInvestment += h * r;

        if (s.start_date && (!minDate || s.start_date < minDate)) minDate = s.start_date;
        if (s.end_date && (!maxDate || s.end_date > maxDate)) maxDate = s.end_date;
      });

      // Apply global discount and tax
      const globalDiscount = investmentConfig.globalDiscount || 0;
      const taxRate = investmentConfig.taxRate || 0;
      const afterDiscount = totalInvestment * (1 - globalDiscount / 100);
      const withTax = afterDiscount * (1 + taxRate / 100);

      // Update the SOW with calculated totals
      await fetch(`/api/sow/${sow.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          totalHours,
          totalInvestment: withTax,
          startDate: minDate,
          endDate: maxDate,
          contentPartial: {
            investment_config: investmentConfig,
            velocity,
          },
        }),
      });

      onSave?.();
    } catch (err) {
      setError('Failed to save SOW. Please try again.');
    } finally {
      setSaving(false);
    }
  }

  // Summary calculations
  const totalHours = sections.reduce((sum, s) => sum + (parseFloat(s.hours) || 0), 0);
  const totalInvestment = sections.reduce((sum, s) => {
    const h = parseFloat(s.hours) || 0;
    const r = parseFloat(s.rate) || 0;
    return sum + (h * r);
  }, 0);
  const unassignedCount = selectedItems.filter(name => !assignedItems[name]).length;

  return (
    <div>
      {/* Error banner */}
      {error && (
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: 'var(--space-3) var(--space-5)',
          background: 'var(--status-warning-bg)',
          border: '1px solid var(--status-warning-bg)',
          borderRadius: 'var(--radius-xl)',
          marginBottom: 'var(--space-4)',
          color: 'var(--status-warning-text)',
          fontSize: 'var(--text-sm)',
        }}>
          <span>{error}</span>
          <button
            onClick={() => setError(null)}
            style={{
              background: 'none',
              border: 'none',
              color: 'var(--status-warning-text)',
              cursor: 'pointer',
              fontSize: 'var(--text-base)',
              padding: '0 0.25rem',
            }}
          >
            x
          </button>
        </div>
      )}

      {/* Auto-generated banner */}
      {isAutoGenerated && (
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: 'var(--space-3) var(--space-5)',
          background: 'var(--status-healthy-bg)',
          border: '1px solid var(--status-healthy-bg)',
          borderRadius: 'var(--radius-xl)',
          marginBottom: 'var(--space-4)',
          fontSize: 'var(--text-sm)',
          color: 'var(--status-healthy-text)',
        }}>
          <span>
            âœ¨ <strong>{sections.length} sections</strong> were auto-generated from your diagnostic results.
            Review and adjust hours, rates, and deliverables as needed.
          </span>
          <div style={{ display: 'flex', gap: 'var(--space-2)', alignItems: 'center' }}>
            <select
              value={groupBy}
              onChange={handleGroupByChange}
              style={{
                padding: '0.3rem 0.5rem',
                border: '1px solid var(--status-healthy-bg)',
                borderRadius: 'var(--radius-md)',
                fontSize: 'var(--text-xs)',
                background: 'var(--bg-white)',
                color: 'var(--status-healthy-text)',
              }}
            >
              <option value="function">Group by Function</option>
              <option value="outcome">Group by Outcome</option>
            </select>
            <button
              onClick={handleRegenerate}
              disabled={regenerating}
              style={{
                padding: 'var(--space-1) var(--space-3)',
                background: '#276749',
                color: 'white',
                border: 'none',
                borderRadius: 'var(--radius-md)',
                fontSize: 'var(--text-xs)',
                fontWeight: 'var(--font-medium)',
                cursor: regenerating ? 'wait' : 'pointer',
                opacity: regenerating ? 0.7 : 1,
              }}
            >
              {regenerating ? 'Regenerating...' : 'ðŸ”„ Regenerate'}
            </button>
          </div>
        </div>
      )}

      {/* Executive Summary Editor */}
      {(executiveSummary || isAutoGenerated) && (
        <ExecutiveSummaryEditor
          value={executiveSummary}
          onChange={setExecutiveSummary}
          sowId={sow.id}
          diagnosticResult={diagnosticResult}
          customerName={sow.content?.client_info?.company}
          templateVars={{
            customerName: sow.content?.client_info?.company,
            overallRating: sow.overall_rating,
            warningCount: processes.filter(p => p.status === 'warning').length,
            functionBreakdown: [...new Set(processes.map(p => p.function).filter(Boolean))].join(', '),
          }}
        />
      )}

      {/* Summary bar */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: 'var(--space-4) var(--space-5)',
        background: 'var(--bg-subtle)',
        border: '1px solid var(--border-color)',
        borderRadius: 'var(--radius-xl)',
        marginBottom: 'var(--space-6)',
        flexWrap: 'wrap',
        gap: 'var(--space-3)',
      }}>
        <div style={{ display: 'flex', gap: 'var(--space-6)', fontSize: 'var(--text-sm)' }}>
          <SummaryItem label="Sections" value={sections.length} />
          <SummaryItem label="Total Hours" value={totalHours} />
          <SummaryItem label="Total Investment" value={`$${totalInvestment.toLocaleString()}`} color="#276749" />
          <SummaryItem label="Items Selected" value={selectedItems.length} />
          {unassignedCount > 0 && (
            <SummaryItem label="Unassigned" value={unassignedCount} color="#E53E3E" />
          )}
        </div>
        <div style={{ display: 'flex', gap: 'var(--space-3)' }}>
          <button
            onClick={handleSaveAll}
            disabled={saving}
            style={{
              padding: 'var(--space-2) var(--space-5)',
              background: 'var(--ls-purple-light)',
              color: 'white',
              border: 'none',
              borderRadius: 'var(--radius-md)',
              fontSize: 'var(--text-sm)',
              fontWeight: 'var(--font-semibold)',
              cursor: saving ? 'wait' : 'pointer',
              opacity: saving ? 0.7 : 1,
            }}
          >
            {saving ? 'Saving...' : 'Save SOW'}
          </button>
        </div>
      </div>

      {/* Investment Configurator */}
      <InvestmentConfigurator
        sections={sections}
        config={investmentConfig}
        onConfigChange={saveInvestmentConfig}
        onApplyRateToAll={applyRateToAll}
      />

      {/* Two-panel layout */}
      <div style={{
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: 'var(--space-6)',
        alignItems: 'start',
      }}>
        {/* Left panel: Diagnostic Item Picker */}
        <div>
          <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: 'var(--space-3)',
          }}>
            <h3 style={{ fontSize: 'var(--text-base)', fontWeight: 'var(--font-semibold)', color: 'var(--gray-900)', margin: 0 }}>
              Diagnostic Items
            </h3>
            {activeSection && unassignedCount > 0 && (
              <button
                onClick={() => assignItemsToSection(activeSection)}
                style={{
                  padding: 'var(--space-1) var(--space-3)',
                  background: 'var(--ls-purple-light)',
                  color: 'white',
                  border: 'none',
                  borderRadius: 'var(--radius-md)',
                  fontSize: 'var(--text-xs)',
                  fontWeight: 'var(--font-medium)',
                  cursor: 'pointer',
                }}
              >
                Add {unassignedCount} to Section
              </button>
            )}
          </div>
          <DiagnosticItemPicker
            processes={processes}
            selectedItems={selectedItems}
            onSelectionChange={setSelectedItems}
            assignedItems={assignedItems}
          />
        </div>

        {/* Right panel: Sections */}
        <div>
          <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: 'var(--space-3)',
          }}>
            <h3 style={{ fontSize: 'var(--text-base)', fontWeight: 'var(--font-semibold)', color: 'var(--gray-900)', margin: 0 }}>
              SOW Sections
            </h3>
            <div style={{ display: 'flex', gap: 'var(--space-2)' }}>
              <button
                onClick={() => setShowCatalog(true)}
                style={{
                  padding: 'var(--space-1) var(--space-3)',
                  background: 'var(--status-healthy)',
                  color: 'white',
                  border: 'none',
                  borderRadius: 'var(--radius-md)',
                  fontSize: 'var(--text-xs)',
                  fontWeight: 'var(--font-medium)',
                  cursor: 'pointer',
                }}
              >
                + From Catalog
              </button>
              <button
                onClick={addSection}
                style={{
                  padding: 'var(--space-1) var(--space-3)',
                  background: 'var(--ls-purple-light)',
                  color: 'white',
                  border: 'none',
                  borderRadius: 'var(--radius-md)',
                  fontSize: 'var(--text-xs)',
                  fontWeight: 'var(--font-medium)',
                  cursor: 'pointer',
                }}
              >
                + Blank Section
              </button>
            </div>
          </div>

          {sections.length === 0 ? (
            <div style={{
              padding: 'var(--space-12) var(--space-8)',
              textAlign: 'center',
              border: '2px dashed #E2E8F0',
              borderRadius: 'var(--radius-xl)',
              color: 'var(--text-muted)',
            }}>
              <p style={{ fontSize: 'var(--text-sm)', marginBottom: 'var(--space-3)' }}>
                No sections yet. Create sections to organize diagnostic items into SOW bundles.
              </p>
              <button
                onClick={addSection}
                style={{
                  padding: 'var(--space-2) var(--space-4)',
                  background: 'var(--ls-purple-light)',
                  color: 'white',
                  border: 'none',
                  borderRadius: 'var(--radius-md)',
                  fontSize: 'var(--text-sm)',
                  cursor: 'pointer',
                }}
              >
                Create First Section
              </button>
            </div>
          ) : (
            <div style={{ display: 'flex', flexDirection: 'column', gap: 'var(--space-4)' }}>
              {sections.map((section, index) => (
                <div
                  key={section.id}
                  draggable
                  onDragStart={() => handleDragStart(index)}
                  onDragEnter={() => handleDragEnter(index)}
                  onDragEnd={handleDragEnd}
                  onDragOver={(e) => e.preventDefault()}
                  onClick={() => setActiveSection(section.id)}
                  style={{
                    outline: activeSection === section.id ? '2px solid #6C5CE7' : 'none',
                    outlineOffset: '2px',
                    borderRadius: 'var(--radius-xl)',
                    cursor: 'grab',
                  }}
                >
                  <SectionConfigurator
                    section={section}
                    onUpdate={(updates) => updateSection(section.id, updates)}
                    onDelete={() => deleteSection(section.id)}
                    diagnosticItems={processMap}
                    defaultRate={investmentConfig.defaultRate}
                    velocity={velocity}
                    currency={investmentConfig.currency}
                  />
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Catalog picker modal */}
      {showCatalog && (
        <CatalogPicker
          onSelect={addSectionFromCatalog}
          onCancel={() => setShowCatalog(false)}
        />
      )}

      {/* Timeline Configurator */}
      <TimelineConfigurator
        sections={sections}
        onUpdateSection={(sectionId, updates) => updateSection(sectionId, updates)}
        velocity={velocity}
        onVelocityChange={handleVelocityChange}
      />

      {/* Assumptions & Acceptance Criteria Editor */}
      <AssumptionsEditor
        assumptions={sow?.content?.assumptions}
        acceptanceCriteria={sow?.content?.acceptance_criteria}
        sowId={sow.id}
      />
    </div>
  );
}

function SummaryItem({ label, value, color }) {
  return (
    <div>
      <div style={{ fontSize: 'var(--text-xs)', color: 'var(--text-muted)', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
        {label}
      </div>
      <div style={{ fontWeight: 'var(--font-semibold)', color: color || '#1a1a2e' }}>
        {value}
      </div>
    </div>
  );
}
