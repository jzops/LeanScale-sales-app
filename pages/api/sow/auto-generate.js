/**
 * POST /api/sow/auto-generate
 *
 * Generate (or regenerate) SOW sections from diagnostic results.
 *
 * Body: {
 *   diagnosticResultId: UUID (required),
 *   groupBy?: 'function' | 'outcome',
 *   customerId?: UUID,
 *   customerName?: string,
 *   // Pricing is retainer-based (tier model); no defaultRate needed
 *   startDate?: string (ISO date),
 *   sowId?: UUID (if regenerating an existing SOW),
 *   preserveManual?: boolean (keep manually-added sections on regenerate),
 * }
 */

import { createSow, updateSow } from '../../../lib/sow';
import { getDiagnosticResult } from '../../../lib/diagnostics';
import { bulkCreateSections, listSections, deleteSection } from '../../../lib/sow-sections';
import { autoGenerateSow } from '../../../lib/sow-auto-builder';
import { supabaseAdmin } from '../../../lib/supabase';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ success: false, error: 'Method not allowed' });
  }

  try {
    const {
      diagnosticResultId,
      groupBy = 'function',
      customerId,
      customerName,
      defaultRate, // deprecated â€” pricing is retainer-based
      startDate,
      sowId,
      preserveManual = true,
    } = req.body;

    if (!diagnosticResultId) {
      return res.status(400).json({ success: false, error: 'diagnosticResultId is required' });
    }

    // Fetch diagnostic result
    // If customerId provided, use it; otherwise look up by ID directly
    let diagnosticResult;
    if (customerId) {
      diagnosticResult = await getDiagnosticResult(customerId, 'gtm');
    }
    if (!diagnosticResult && supabaseAdmin) {
      const { data } = await supabaseAdmin
        .from('diagnostic_results')
        .select('*')
        .eq('id', diagnosticResultId)
        .single();
      diagnosticResult = data;
    }

    if (!diagnosticResult) {
      return res.status(404).json({ success: false, error: 'Diagnostic result not found' });
    }

    const processes = diagnosticResult.processes || [];

    // Run auto-generation engine
    const {
      sections: sectionDefs,
      executiveSummary,
      priorityItems,
      statusCounts,
    } = await autoGenerateSow({
      processes,
      groupBy,
      defaultRate,
      sowStartDate: startDate,
      customerName,
      diagnosticType: diagnosticResult.diagnostic_type || 'gtm',
    });

    // Determine target SOW
    let sow;
    if (sowId) {
      // Regenerate: delete existing auto-generated sections
      const existingSections = await listSections(sowId);
      for (const section of existingSections) {
        const isAutoGenerated = section.diagnostic_items && section.diagnostic_items.length > 0;
        if (!preserveManual || isAutoGenerated) {
          await deleteSection(section.id);
        }
      }

      // Update SOW content
      sow = await updateSow(sowId, {
        content: {
          executive_summary: executiveSummary,
        },
      });

      if (!sow) {
        return res.status(404).json({ success: false, error: 'SOW not found' });
      }
    } else {
      // Create new SOW
      const criticalPct = (statusCounts.warning + statusCounts.unable) / (processes.length || 1);
      let overallRating = 'healthy';
      if (criticalPct > 0.5) overallRating = 'critical';
      else if (criticalPct > 0.3) overallRating = 'warning';
      else if (criticalPct > 0.1) overallRating = 'moderate';

      const title = customerName ? `${customerName} Statement of Work` : 'Statement of Work';

      sow = await createSow({
        customerId,
        title,
        sowType: 'custom',
        content: {
          executive_summary: executiveSummary,
          client_info: customerName ? { company: customerName } : {},
          assumptions: [
            'Client will provide timely access to required systems and stakeholders.',
            'Scope changes will be managed through a change request process.',
            'All work will be performed remotely unless otherwise agreed.',
          ],
          acceptance_criteria: [
            'Deliverables reviewed and approved by client stakeholder.',
            'Knowledge transfer session completed for each section.',
          ],
        },
      });

      if (!sow) {
        return res.status(500).json({ success: false, error: 'Failed to create SOW' });
      }

      await updateSow(sow.id, {
        diagnostic_result_ids: [diagnosticResultId],
        overall_rating: overallRating,
        diagnostic_snapshot: {
          processes: processes.map(p => ({
            name: p.name,
            status: p.status,
            addToEngagement: p.addToEngagement,
            function: p.function,
            outcome: p.outcome,
            serviceId: p.serviceId,
            serviceType: p.serviceType,
          })),
          snapshotAt: new Date().toISOString(),
        },
      });
    }

    // Create sections
    let generatedSections = [];
    if (sectionDefs.length > 0) {
      generatedSections = await bulkCreateSections(sow.id, sectionDefs);

      // Update SOW totals
      let totalHours = 0, totalInvestment = 0;
      let minDate = null, maxDate = null;
      generatedSections.forEach(s => {
        const h = parseFloat(s.hours) || 0;
        const r = parseFloat(s.rate) || 0;
        totalHours += h;
        totalInvestment += h * r;
        if (s.start_date && (!minDate || s.start_date < minDate)) minDate = s.start_date;
        if (s.end_date && (!maxDate || s.end_date > maxDate)) maxDate = s.end_date;
      });

      await updateSow(sow.id, {
        total_hours: totalHours,
        total_investment: totalInvestment,
        start_date: minDate,
        end_date: maxDate,
      });
    }

    return res.status(sowId ? 200 : 201).json({
      success: true,
      data: {
        ...sow,
        sections: generatedSections,
      },
      meta: {
        autoGenerated: true,
        sectionsCreated: generatedSections.length,
        priorityItemCount: priorityItems.length,
        groupBy,
        regenerated: !!sowId,
      },
    });
  } catch (error) {
    console.error('Error in auto-generate SOW:', error);
    return res.status(500).json({ success: false, error: 'Internal server error' });
  }
}
