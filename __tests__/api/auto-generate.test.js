/**
 * Tests for pages/api/sow/auto-generate.js
 */

// Mock dependencies
jest.mock('../../lib/sow', () => ({
  createSow: jest.fn(),
  updateSow: jest.fn(),
}));

jest.mock('../../lib/diagnostics', () => ({
  getDiagnosticResult: jest.fn(),
}));

jest.mock('../../lib/sow-sections', () => ({
  bulkCreateSections: jest.fn(),
  listSections: jest.fn(),
  deleteSection: jest.fn(),
}));

jest.mock('../../lib/sow-auto-builder', () => ({
  autoGenerateSow: jest.fn(),
}));

const mockSupabaseFrom = jest.fn();
const mockSingle = jest.fn();

jest.mock('../../lib/supabase', () => ({
  supabaseAdmin: {
    from: (...args) => {
      mockSupabaseFrom(...args);
      return {
        select: () => ({
          eq: () => ({
            single: () => mockSingle(),
          }),
        }),
      };
    },
  },
}));

const { createSow, updateSow } = require('../../lib/sow');
const { getDiagnosticResult } = require('../../lib/diagnostics');
const { bulkCreateSections, listSections, deleteSection } = require('../../lib/sow-sections');
const { autoGenerateSow } = require('../../lib/sow-auto-builder');

let handler;
beforeAll(() => {
  handler = require('../../pages/api/sow/auto-generate').default;
});

afterEach(() => {
  jest.clearAllMocks();
});

function createMocks({ method = 'POST', body = {} } = {}) {
  return {
    req: { method, body },
    res: {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis(),
    },
  };
}

const MOCK_DIAGNOSTIC = {
  id: 'diag-1',
  customer_id: 'cust-1',
  diagnostic_type: 'gtm',
  processes: [
    { name: 'Lead Routing', status: 'warning', addToEngagement: true, function: 'Sales', serviceId: 'lead-routing' },
    { name: 'Pipeline', status: 'healthy', addToEngagement: false, function: 'Sales', serviceId: 'pipeline-mgmt' },
  ],
};

const MOCK_AUTO_RESULT = {
  sections: [
    { title: 'Lead Routing', hours: 40, rate: 200, deliverables: [], diagnosticItems: ['Lead Routing'], sortOrder: 0 },
  ],
  executiveSummary: 'Test summary',
  priorityItems: [MOCK_DIAGNOSTIC.processes[0]],
  statusCounts: { warning: 1, unable: 0, careful: 0, healthy: 1 },
};

describe('POST /api/sow/auto-generate', () => {
  // ==========================================
  // Method validation
  // ==========================================
  test('returns 405 for non-POST', async () => {
    const { req, res } = createMocks({ method: 'GET' });
    await handler(req, res);
    expect(res.status).toHaveBeenCalledWith(405);
  });

  // ==========================================
  // Input validation
  // ==========================================
  test('returns 400 when diagnosticResultId is missing', async () => {
    const { req, res } = createMocks({ body: {} });
    await handler(req, res);
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith(
      expect.objectContaining({ error: 'diagnosticResultId is required' })
    );
  });

  // ==========================================
  // Missing diagnostic result
  // ==========================================
  test('returns 404 when diagnostic result not found', async () => {
    getDiagnosticResult.mockResolvedValue(null);
    mockSingle.mockReturnValue({ data: null, error: { message: 'Not found' } });

    const { req, res } = createMocks({
      body: { diagnosticResultId: 'diag-1', customerId: 'cust-1' },
    });
    await handler(req, res);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  // ==========================================
  // Successful generation (new SOW)
  // ==========================================
  test('creates new SOW with sections on success', async () => {
    getDiagnosticResult.mockResolvedValue(MOCK_DIAGNOSTIC);
    autoGenerateSow.mockResolvedValue(MOCK_AUTO_RESULT);

    const createdSow = { id: 'sow-1', title: 'Statement of Work' };
    createSow.mockResolvedValue(createdSow);
    updateSow.mockResolvedValue(createdSow);

    const createdSections = [{ id: 'sec-1', ...MOCK_AUTO_RESULT.sections[0], hours: 40, rate: 200 }];
    bulkCreateSections.mockResolvedValue(createdSections);

    const { req, res } = createMocks({
      body: {
        diagnosticResultId: 'diag-1',
        customerId: 'cust-1',
        customerName: 'Acme Corp',
      },
    });
    await handler(req, res);

    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.json).toHaveBeenCalledWith(
      expect.objectContaining({
        success: true,
        meta: expect.objectContaining({
          autoGenerated: true,
          sectionsCreated: 1,
          regenerated: false,
        }),
      })
    );
    expect(createSow).toHaveBeenCalledWith(
      expect.objectContaining({
        title: 'Acme Corp Statement of Work',
        sowType: 'custom',
      })
    );
  });

  // ==========================================
  // Regeneration with existing SOW
  // ==========================================
  test('regenerates existing SOW by deleting auto sections', async () => {
    getDiagnosticResult.mockResolvedValue(MOCK_DIAGNOSTIC);
    autoGenerateSow.mockResolvedValue(MOCK_AUTO_RESULT);

    const existingSow = { id: 'sow-1', title: 'Existing SOW' };
    updateSow.mockResolvedValue(existingSow);

    listSections.mockResolvedValue([
      { id: 'sec-old', diagnostic_items: ['Lead Routing'] },
      { id: 'sec-manual', diagnostic_items: [] },
    ]);
    deleteSection.mockResolvedValue(true);

    const createdSections = [{ id: 'sec-new', hours: 40, rate: 200 }];
    bulkCreateSections.mockResolvedValue(createdSections);

    const { req, res } = createMocks({
      body: {
        diagnosticResultId: 'diag-1',
        customerId: 'cust-1',
        sowId: 'sow-1',
      },
    });
    await handler(req, res);

    expect(res.status).toHaveBeenCalledWith(200);
    // Should delete auto-generated section but not manual
    expect(deleteSection).toHaveBeenCalledWith('sec-old');
    expect(deleteSection).not.toHaveBeenCalledWith('sec-manual');
    expect(res.json).toHaveBeenCalledWith(
      expect.objectContaining({
        meta: expect.objectContaining({ regenerated: true }),
      })
    );
  });

  // ==========================================
  // Error handling
  // ==========================================
  test('returns 500 when createSow fails', async () => {
    getDiagnosticResult.mockResolvedValue(MOCK_DIAGNOSTIC);
    autoGenerateSow.mockResolvedValue(MOCK_AUTO_RESULT);
    createSow.mockResolvedValue(null);

    const { req, res } = createMocks({
      body: { diagnosticResultId: 'diag-1', customerId: 'cust-1' },
    });
    await handler(req, res);
    expect(res.status).toHaveBeenCalledWith(500);
  });

  test('returns 500 on unexpected error', async () => {
    getDiagnosticResult.mockRejectedValue(new Error('DB down'));

    const { req, res } = createMocks({
      body: { diagnosticResultId: 'diag-1', customerId: 'cust-1' },
    });
    await handler(req, res);
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith(
      expect.objectContaining({ error: 'Internal server error' })
    );
  });
});
